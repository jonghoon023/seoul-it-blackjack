# Seoul.It.Blackjack 수업용 구조 최적화 제안/확정 문서 (5~6시간 기준)

## 1. 문서 목적
- 본 문서는 현재 구현을 유지한 상태에서, 고등학생 대상 수업(이론 + 실습 타이핑) `5~6시간` 완주 가능성을 높이기 위한 **축약 후보**를 정리합니다.
- 핵심 규칙(딜러 키, 단일 딜러, 턴 규칙, 전원 상태 브로드캐스트, 딜러 퇴장 시 게임 종료)은 유지하고, 난이도와 설명량이 큰 부분만 줄이는 것을 목표로 합니다.
- 이 문서는 결정용 초안이며, 실제 반영 여부는 검토 후 확정합니다.

## 1.1 현재 확정 상태 (반영 완료 기준)
- 아래 항목은 이번 라운드의 최종 확정값입니다.
1. `Queue 유지형`을 채택한다. (`Channel` 기반 단일 소비 루프 유지)
2. `DealerOptions`, `GameRuleOptions` 옵션 패턴을 유지한다.
3. 예외 계층(`GameRoomException` + 파생 예외)을 유지한다.
4. 결과 모델(`GameCommand`, `GameOperationResult`, `GameNotice`)을 유지한다.
5. 테스트 프로젝트는 **강사/개발자 검증용**이며 학생 타이핑 대상이 아니다.
6. 수업은 생산 코드 중심(`Core + Backend + Client`)으로 진행하고, 테스트는 시연/사후 검증으로 분리한다.

## 1.2 문서 해석 규칙
1. `2~3장`은 이번 확정안의 기준이다.
2. `4~8장`은 검토 과정에서 논의된 후보안 이력이다.
3. `4~8장`의 "미채택 후보" 내용은 현재 구현 지시가 아니다.

## 2. 전제 및 유지해야 할 불변 조건
- 기준 문서: `docs/Seoul.It.Blackjack.design.md`
- 유지할 정책:
1. `Join/Leave/StartRound/Hit/Stand` 계약 유지
2. 딜러는 `DealerOptions.Key` 기반 지정, 방 내 최대 1명
3. `Hit/Stand` 성공 시 `Clients.All.StateChanged` 전송
4. 규칙 위반은 요청자에게만 `Error(code, message)`
5. 딜러 퇴장 시 `GAME_TERMINATED` 전원 통지 + 상태 초기화
6. 점수 21은 해당 플레이어 행동 종료(라운드 즉시 종료 아님)

## 3. 현재 난이도 진단 요약
- 학습 부담이 큰 지점:
1. 비동기 직렬 처리 파이프라인(`Channel`, 소비 루프, `TaskCompletionSource`)
2. 내부 결과 모델 계층(`GameCommand`, `GameOperationResult`, `GameNotice`)
3. 옵션 바인딩 + 확장 메서드 기반 DI 구성
4. 예외 계층 4종 분리
5. 통합 테스트 19개 전체를 실습 중 함께 다루는 구조

- 핵심 판단:
1. 운영/품질 관점에서는 현재 구조가 우수합니다.
2. 그러나 고등학생 실습 수업에서는 개념 전환 횟수가 많아 집중력이 분산됩니다.
3. 수업 버전은 "완성 경험"이 우선이므로, 구조적 정교함 일부를 후순위로 두는 것이 유리합니다.

---

## 4. 축약안 1: 동시성 처리 구조 축약 (검토 이력, 미채택 후보)

### 4.1 현재 구조(학습 난이도 높음)
- 관련 파일:
1. `src/Seoul.It.Blackjack.Backend/Services/GameRoomService.cs`
2. `src/Seoul.It.Blackjack.Backend/Hubs/GameSessionHub.cs`
- 현재 핵심 요소:
1. `Channel<QueueItem>` 생성
2. `Task.Run(ProcessLoopAsync)`로 백그라운드 처리
3. `await foreach`로 명령 소비
4. `TaskCompletionSource`로 요청-응답 연결

### 4.2 수업에서 어려운 이유
1. "비동기 큐 + 백그라운드 루프 + 완료 통지"를 한 번에 설명해야 합니다.
2. 학생 입장에서 "왜 그냥 메서드 호출하지 않나요?" 질문이 자연스럽게 나옵니다.
3. 디버깅 시 호출 스택이 직관적이지 않아 초반 학습 피로가 큽니다.

### 4.3 축약 목표
- 수업에서는 **직렬 처리 의도만 유지**하고 구현 메커니즘을 단순화합니다.
- 권장 축약 방식:
1. `SemaphoreSlim(1,1)` 또는 `lock` 기반 단일 임계구역 처리
2. Hub 요청이 들어오면 서비스 내부에서 바로 상태 변경
3. 백그라운드 큐 루프/QueueItem/TCS 제거

### 4.4 학생에게 설명하는 방식(멘트 예시)
- 설명 프레임:
1. "지금은 동시에 눌러도 한 명씩 처리되게 문 앞에 줄 세운다."
2. "고급 큐 시스템은 나중 단계에서 다시 배운다."
3. "오늘 목표는 게임 규칙 구현과 상태 흐름 이해다."

- 보드 비유:
1. 문지기 1명(`SemaphoreSlim`)
2. 들어온 요청은 한 명씩 처리
3. 처리 끝나면 다음 사람 입장

### 4.5 타이핑 순서(수업 진행안)
1. `GameRoomService` 상단에 `_gate` 필드 추가
2. 공개 메서드(`JoinAsync`, `StartRoundAsync` 등)에서 공통 `ExecuteLockedAsync` 호출
3. 기존 `Channel`, `ProcessLoopAsync`, `QueueItem`, `Enqueue` 제거
4. 테스트 재실행으로 동작 동일성 확인

### 4.6 기대 효과
1. 비동기 설명량 대폭 감소
2. 호출 흐름이 직선형으로 바뀌어 디버깅 쉬움
3. 수업 시간 약 `40~60분` 절감 기대

### 4.7 주의점
1. 장기적으로는 큐 모델이 더 확장성이 좋습니다.
2. 수업 종료 후 "고급 동시성 버전" 확장 과제로 복원 가능하게 안내해야 합니다.

---

## 5. 축약안 2: 결과/명령 래퍼 계층 축약 (검토 이력, 미채택 후보)

### 5.1 현재 구조
- 관련 파일:
1. `src/Seoul.It.Blackjack.Backend/Services/Commands/GameCommand.cs`
2. `src/Seoul.It.Blackjack.Backend/Services/Commands/GameOperationResult.cs`
3. `src/Seoul.It.Blackjack.Backend/Services/Commands/GameNotice.cs`
4. `src/Seoul.It.Blackjack.Backend/Hubs/GameSessionHub.cs`

### 5.2 수업에서 어려운 이유
1. "요청 객체", "결과 객체", "공지 객체"를 각각 배워야 합니다.
2. 학생 입장에서는 "메서드가 왜 또 객체를 감싸서 반환하는지" 추적이 어렵습니다.
3. 신호 흐름(요청자 오류 vs 전원 공지 vs 전원 상태)을 객체 설계로 이해해야 하므로 인지 부하가 큽니다.

### 5.3 축약 목표
- 수업 버전은 흐름을 단순화합니다.
1. 성공: `GameState` 반환 후 `Clients.All.StateChanged`
2. 실패: `GameRoomException` throw 후 `Clients.Caller.Error`
3. 특수 공지(`GAME_TERMINATED`, `SHOE_EMPTY`)는 Hub/Service에서 명시 호출

### 5.4 학생에게 설명하는 방식(멘트 예시)
1. "성공하면 상태 하나 보내고, 실패하면 에러 하나 보낸다."
2. "중간 포장 박스(래퍼)를 줄여서 데이터 길을 단순하게 만든다."
3. "네트워크에서는 단순한 규칙이 디버깅에 유리하다."

### 5.5 타이핑 순서(수업 진행안)
1. 서비스 반환형을 우선 단순화
2. Hub에서 성공/실패 전송 분기 직접 처리
3. 불필요한 래퍼 타입 제거
4. 딜러 종료 알림 순서(`Error` 후 `StateChanged`) 검증

### 5.6 기대 효과
1. 객체 간 참조 추적 감소
2. SignalR 흐름 설명이 직관적으로 변경
3. 수업 시간 약 `25~40분` 절감 기대

### 5.7 주의점
1. 래퍼 제거 시 전송 정책이 코드에 분산될 수 있습니다.
2. 정책이 흩어지지 않게 Hub 메서드 패턴을 통일해야 합니다.

---

## 6. 축약안 3: 옵션/DI 설명량 축약 (검토 이력, 미채택 후보)

### 6.1 현재 구조
- 관련 파일:
1. `src/Seoul.It.Blackjack.Backend/Options/GameRuleOptions.cs`
2. `src/Seoul.It.Blackjack.Backend/Options/DealerOptions.cs`
3. `src/Seoul.It.Blackjack.Backend/Extensions/ServiceCollectionExtensions.cs`
4. `src/Seoul.It.Blackjack.Backend/Program.cs`

### 6.2 수업에서 어려운 이유
1. "설정 파일 바인딩", "옵션 패턴", "DI 주입"이 동시에 등장합니다.
2. 규칙 구현보다 프레임워크 구성 설명이 길어집니다.
3. 학생이 핵심 로직보다 설정 문법을 더 오래 따라쓰게 됩니다.

### 6.3 축약 목표
- 수업 1차 버전은 규칙값을 코드 상수로 고정합니다.
1. `DeckCount=4`
2. `DealerStandScore=17`
3. `MinPlayersToStart=2`
4. `Name length 1~20`
- `DealerOptions.Key`는 유지(딜러 시나리오 핵심이기 때문)

### 6.4 학생에게 설명하는 방식(멘트 예시)
1. "오늘은 게임 규칙 구현에 집중하기 위해 숫자를 고정한다."
2. "운영 환경에서는 이 숫자를 설정 파일로 빼는 게 맞다."
3. "설정 외부화는 다음 단계 리팩터링 미션이다."

### 6.5 타이핑 순서(수업 진행안)
1. 규칙 숫자를 상수로 선언
2. 로직에서 상수 참조
3. 마지막 10분에 "옵션 패턴으로 바꾸면 어디가 바뀌는지"만 개념 소개

### 6.6 기대 효과
1. 초기 진입 속도 향상
2. DI/옵션 설명 부담 감소
3. 수업 시간 약 `20~30분` 절감 기대

### 6.7 주의점
1. 운영 전환 시 상수 외부화 리팩터링이 필요합니다.
2. 문서에 "수업 버전 고정값"을 명확히 기록해야 합니다.

---

## 7. 축약안 4: 예외 계층 단순화 (검토 이력, 미채택 후보)

### 7.1 현재 구조
- 관련 파일:
1. `src/Seoul.It.Blackjack.Backend/Services/Exceptions/GameRoomException.cs`
2. `src/Seoul.It.Blackjack.Backend/Services/Exceptions/GameValidationException.cs`
3. `src/Seoul.It.Blackjack.Backend/Services/Exceptions/GameRuleException.cs`
4. `src/Seoul.It.Blackjack.Backend/Services/Exceptions/GameAuthorizationException.cs`

### 7.2 수업에서 어려운 이유
1. 예외 타입 분류 자체가 초심자에게 추상적으로 느껴집니다.
2. "왜 같은 에러코드인데 타입이 다른가?"라는 질문이 생깁니다.
3. 핵심은 코드/메시지 전송인데 타입 계층 설명이 길어집니다.

### 7.3 축약 목표
- 수업 버전은 `GameRoomException` 단일 타입 사용:
1. `Code`
2. `Message`
- 분류는 주석/문서로만 유지하고, 타입 계층은 확장 과제로 이동

### 7.4 학생에게 설명하는 방식(멘트 예시)
1. "서버 에러는 코드 하나로 구분한다."
2. "에러의 종류를 클래스 여러 개로 나누는 건 유지보수 심화 단계다."
3. "오늘은 Error(code, message) 전달이 목표다."

### 7.5 타이핑 순서(수업 진행안)
1. 단일 예외 클래스 생성
2. 기존 throw 지점 모두 단일 타입으로 통일
3. Hub에서 단일 catch 처리
4. 테스트로 에러 코드 발생 조건 검증

### 7.6 기대 효과
1. 예외 파트 설명량 축소
2. 학생이 에러 흐름을 빠르게 이해
3. 수업 시간 약 `15~25분` 절감 기대

### 7.7 주의점
1. 대규모 프로젝트에서는 예외 분류가 유리합니다.
2. 수업 버전 종료 후, 리팩터링 예제로 계층 분리를 다시 소개할 수 있습니다.

---

## 8. 축약안 5: 통합 테스트 실습 범위 축약 (검토 이력, 일부만 채택)

### 8.1 현재 구조
- 관련 폴더:
1. `src/Seoul.It.Blackjack.Backend.Tests`
- 현재 테스트는 19개이며 시나리오 커버리지가 높습니다.

### 8.2 수업에서 어려운 이유
1. TestHost/SignalR 클라이언트 헬퍼까지 설명하면 수업 본론 시간이 줄어듭니다.
2. 테스트 타이핑이 길어지면 "게임 완성 경험"이 약해집니다.
3. 학생 입장에서 실패 원인(네트워크/타이밍/로직) 분리가 어렵습니다.

### 8.3 축약 목표
- 수업 중에는 "핵심 검증 3~5개"만 같이 작성합니다.
- 전체 통합 테스트 19개는 강사/개발자 검증용으로 유지합니다.

### 8.4 수업용 최소 테스트 추천(함께 타이핑)
1. 딜러 키 일치/불일치 Join
2. 비딜러 StartRound 거부(`NOT_DEALER`)
3. Hit/Stand 전원 브로드캐스트
4. 딜러 퇴장 시 `GAME_TERMINATED` + 상태 초기화

### 8.5 학생에게 설명하는 방식(멘트 예시)
1. "테스트는 안전망이지만, 오늘은 핵심 길목만 직접 만든다."
2. "전체 회귀 테스트는 선생님이 준비한 검증 세트로 돌린다."
3. "실무에서도 핵심 시나리오부터 우선 테스트를 구축한다."

### 8.6 타이핑 순서(수업 진행안)
1. 테스트 헬퍼는 제공 파일로 시작
2. 핵심 테스트 1개 성공 경험 먼저 제공
3. 패턴 복제로 2~4개 확장
4. 마지막에 전체 테스트 실행은 시연만

### 8.7 기대 효과
1. 수업 리듬 유지
2. "완성-검증" 균형 확보
3. 수업 시간 약 `40~70분` 절감 기대

---

## 9. 수업 진행용 설명 스크립트(요약 템플릿)

### 9.1 각 파트 공통 3문장 템플릿
1. "이 파트의 목표는 무엇인지" 먼저 1문장
2. "왜 단순화했는지" 1문장
3. "다음 단계에서 어떻게 고급화할지" 1문장

### 9.2 실제 진행 예시
1. "지금은 한 줄로 처리되는 단순한 길을 만들고, 복잡한 길은 숙제로 넘기겠습니다."
2. "중요한 건 규칙이 정확히 동작하고, 모든 사용자에게 상태가 동일하게 보이는 것입니다."
3. "구조 고도화는 오늘 완성 후 리팩터링 과제로 진행합니다."

---

## 10. 확정 조합 및 기대 효과(최종)
### 10.1 확정 적용
1. Queue 유지
2. 옵션/예외/결과모델 유지
3. 테스트 프로젝트의 학생 타이핑 제외 정책 유지

### 10.2 기대 효과
1. 동작/회귀 리스크를 최소화한다.
2. 수업 중 개념 전환을 줄이기 위해 "생산 코드 타이핑 우선" 흐름을 확보한다.
3. 테스트는 강사 검증용으로 분리하여 수업 완주 확률을 높인다.

---

## 11. 최종 확인 체크리스트
- 아래 질문에 "예"가 많으면 수업 난이도가 적절합니다.
1. 학생이 `GameRoomService` 호출 흐름을 10분 내 설명할 수 있는가?
2. 학생이 `Error(code, message)`와 `StateChanged(state)` 차이를 이해하는가?
3. 학생이 "딜러 키 불일치 시 일반 플레이어"를 직접 설명할 수 있는가?
4. 학생이 "딜러 퇴장 시 왜 전원 재Join이 필요한가"를 이해하는가?
5. 실습 중 테스트는 핵심 시나리오 중심으로 끝낼 수 있는가?

---

## 12. 다음 단계 제안(확정 후 실행)
1. `docs/Seoul.It.Blackjack.design.md`에 Queue 유지형 수업 정책을 동기화한다.
2. 큐 인프라를 `GameRoomService`에서 분리해 파일 복잡도를 낮춘다.
3. `GameRoomService`를 300줄 이하로 축소한다.
4. 통합 테스트 전체를 강사 검증 기준으로 유지한다.
